// Generated by CoffeeScript 1.3.3
(function() {
  var Availability,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Availability = (function() {

    function Availability(numCabins) {
      this.numCabins = numCabins != null ? numCabins : 1;
      this.incrementOccupiedCabins = __bind(this.incrementOccupiedCabins, this);

      this.parseGapiResponse = __bind(this.parseGapiResponse, this);

      this.getOccupiedRanges = __bind(this.getOccupiedRanges, this);

      this.updateAvailabilityForMonth = __bind(this.updateAvailabilityForMonth, this);

      this.blackoutMonth = __bind(this.blackoutMonth, this);

      this.occupied = {};
      this.calendarIds = ['lv6qar50diur7kqt1s5vsrk3lo@group.calendar.google.com', '969cqum6os1qcnnqlcdlhhge34@group.calendar.google.com', 'i0sm6j6p47jcta7r55dpgb8jmo@group.calendar.google.com', 'fbp9ha04eolkj57ufkm1plcbu0@group.calendar.google.com'];
    }

    Availability.prototype.blackoutMonth = function(monthDate, callback) {
      var currentDay, end, month, year, _ref, _ref1, _results;
      _ref = [monthDate.year(), monthDate.month()], year = _ref[0], month = _ref[1];
      if ((_ref1 = this.occupied[year]) != null ? _ref1[month] : void 0) {
        currentDay = moment(monthDate).date(1);
        end = moment(currentDay).add('months', 1);
        _results = [];
        while (currentDay < end) {
          if (this.calendarIds.length - this.occupied[year][month][currentDay.date()] < this.numCabins) {
            callback(currentDay);
          }
          _results.push(currentDay = currentDay.add('days', 1));
        }
        return _results;
      } else {
        return this.updateAvailabilityForMonth(month, year, callback);
      }
    };

    Availability.prototype.updateAvailabilityForMonth = function(month, year, blackoutCallback) {
      var _this = this;
      return this.getOccupiedRanges(new Date(year, month), new Date(year, month + 1), function(resp) {
        return _this.parseGapiResponse(resp, blackoutCallback);
      });
    };

    Availability.prototype.getOccupiedRanges = function(start, end, parseCallback) {
      var req,
        _this = this;
      console.log("checking availability for " + start + " to " + end);
      req = gapi.client.request({
        path: '/calendar/v3/freeBusy',
        method: 'POST',
        body: {
          timeMin: start,
          timeMax: end,
          items: this.calendarIds.map(function(id) {
            return {
              'id': id
            };
          })
        }
      });
      return req.execute(function(resp) {
        return parseCallback(resp);
      });
    };

    Availability.prototype.parseGapiResponse = function(resp, blackoutCallback) {
      var _this = this;
      return this.calendarIds.forEach(function(calendarId) {
        return resp.calendars[calendarId].busy.forEach(function(busyRange) {
          var currentDay, end, _results;
          currentDay = moment(busyRange.start);
          end = moment(busyRange.end);
          _results = [];
          while (currentDay < end) {
            _this.incrementOccupiedCabins(currentDay, blackoutCallback);
            _results.push(currentDay = currentDay.add('days', 1));
          }
          return _results;
        });
      });
    };

    Availability.prototype.incrementOccupiedCabins = function(date, blackoutCallback) {
      var day, month, year, _base, _base1, _base2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      _ref = [date.year(), date.month(), date.date()], year = _ref[0], month = _ref[1], day = _ref[2];
      if ((_ref1 = (_base = this.occupied)[year]) == null) {
        _base[year] = {};
      }
      if ((_ref2 = (_base1 = this.occupied[year])[month]) == null) {
        _base1[month] = {};
      }
      if ((_ref3 = (_base2 = this.occupied[year][month])[day]) == null) {
        _base2[day] = 0;
      }
      this.occupied[year][month][day]++;
      if (this.calendarIds.length - ((_ref4 = this.occupied[year]) != null ? (_ref5 = _ref4[month]) != null ? _ref5[day] : void 0 : void 0) < this.numCabins) {
        return blackoutCallback(date);
      }
    };

    return Availability;

  })();

  window.Availability = Availability;

}).call(this);
